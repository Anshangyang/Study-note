# 算法/Algorithms

————

序言：此笔记由笔者于《算法图解》、《算法导论》、浙大陈越老师数据结构课进行算法的学习中，将作者所提及的概念抽取、汇编而成，第一次完整提交只会摘录对于笔者而言有用部分，后续将在第二次、第三次逐渐完善。

---

## 算法定义

- 是一组完成任务的指令，任何代码片段都可视为算法。

- 是任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出，即把输入转换成输出的计算步骤的一个序列。也可以看成是用于求解良说明的计算问题的工具，问题陈述说明了期望的输入/输出关系，算法则描述一个特定的计算过程来实现该输入/输出关系。若对每个正确输入后都以正确的输出停机，则称该算法是正确的，并称正确的算法解决了给定的计算问题。算法问题所共有的两大特征。
    - 存在许多候选解，但绝大多数候选解都没有解决手头问题。
    - 存在实际应用。


---

## 算法种类

1.简单查找。
- 运行时间为线性时间。

2.二分查找。
- 其输入是一个有序的元素列表。
- 使用二分查找时，每次都排除一半。
- 一般而言，对于包含n个元素的列表，用二分查 找最多需要log 2 n步，而简单查找最多需要n步。
- 运行时间为对数时间。

3.选择排序。
- 运行时间为O（n2）。

4.快速排序（重要的D&C算法）。
- 首先，从数组中选择一个元素，这个元素被称为基准值（pivot）。接下来，找出比基准值小的元素以及比基准值大的元素分开组成一组，这被称为分区（partitioning）。最后，如果子数组是有序的，就可以像下面这样合并得到一个有序的数组：左边的数组 + 基准值 + 右边的数组。无序的话快速排序可以将两个元素进行排序，使子数组变成有序。
- 如何应对多数数组进行快速排序？原理与A相同。不同的是，子数组会比A大上许多，但同样对子数组用快速排序进行分区直至子数组包含元素数在0~4以内，前提是快速排序要使用递归来运行。
- 其速度取决于选择的基准值。

5.合并排序。

6.广度优先搜索（图算法）。
- 解决最短路径问题的算法被称为广度优先搜索，需要两个步骤:
    - 使用图来建立问题模型。
    - 使用广度优先搜索解决问题。 
- 广度优先搜索是一种用于图的查找算法，可帮助回答两类问题。第一类问题：从节点A出发，有前往节点B的路径吗？第二类问题：从节点A出发，前往节点B的哪条路径最短？这类问题需注意，只有按添加顺序查找时，才能实现这样的目的，需要按添加顺序进行检查。有一个可实现这种目的的数据结构，那就是队列（queue）。
- 运行时间至少为O（边数），且将一个人添加到队列需要的时间是固定的， 即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。所以，广度优先搜索的运行时间为 O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数。
- 计算非加权图中的最短路径，可使用广度优先搜索。

7.狄克斯特拉算法（Dijkstra’s algorithm）。
- 狄克斯特拉算法包含4个步骤。
    - 找出“最便宜”的节点，即可在最短时间内到达的节点。
    - 更新该节点相邻的邻居。
    - 重复这个过程，直到对图中的每个节点都这样做了。
    - 计算最终路径。
- 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。
- 要计算加权图中的最短路径，可使用狄克斯特拉算法。
- 在无向图中，每条边都是一个环。狄克斯特拉算法只适用于有向无环图（directed acyclic graph，DAG）。
- 如果有负权边，就不能使用狄克斯特拉算法。

8.贝尔曼——福德算法（Bellman-Ford algorithm）。
- 在包含负权边的图中，可找出最短路径。

9.贪婪算法。
- 每步都选择最优解，最终得到的就是全局最优解。

10动态规划。
- 先解决子问题，再逐步解决大问题。每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。
- 需要在给定约束条件下优化某种指标时，动态规划很有用。
- 每种动态规划解决方案都涉及网格。网格是什么样的呢？需要思考单元格中的值是什么？如何将这个问题划分为子问题？网格的坐标轴是什么？单元格中的值通常就是你要优化的值。每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。
各行的排列顺序无关紧要，也可以逐列而不是逐行填充网格。

11.费曼算法（Feynman algorithm）。
- 将问题写下来。
- 好好思考。
- 将答案写下来。

12K 最近邻（k-nearest neighbours，KNN）算法。
- 你先需要对一个数据进行分类，查看与它相邻的数据，在这些数据中那个多就属于哪一类。
- 可用KNN分类，先进行特征抽取，将本质特征抽取出来，绘制成图，计算它们的距离，越短越接近，用KNN时，挑选合适的特征进行比较至关重要。
    - 要与数据紧密相关的特征。
    - 不偏不倚的特征。
- 可用KNN回归，回归就是预测结果。
- 机器学习可用KNN进行训练，即查看大量的数字图像并提取特征，例如：OCR，OCR指的是光学字符识别（optical character recognition）。

13朴素贝叶斯分类器（Naive Bayes classifier）。
- 主要是检索数据中对应的特征进行训练。

14.傅里叶变换。
- 非常适合用于处理信号。

15.并行算法。
- 与可扩展性和海量数据处理相关，并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难，有一点是确定的，那就是速度的提升并非线性的，原因有二:
    - 并行性管理开销，指并行运算时，合并结果所耗费的时间。
    - 负载均衡。

16.MapReduce——分布式算法。
- 分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（map）函数和归并（reduce）函数。
- 映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理，映射是将一个数组转换为另一个数组。归并函数的理念是将很多项归并为一项，归并是将一个数组转换为一个元素。

17.HyperLogLog。
- HyperLogLog是一种类似于布隆过滤器的算法，HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。

18.SHA 算法，即安全散列算法（secure hash algorithm，SHA）函数，也是一种散列函数。
- 给定一个字符串，SHA返回其散列值——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串，对于每个不同的字符串，SHA生成的散列值都不同。
- 可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。假设你有一个4 GB 的文件，并要检查朋友是否也有这个大型文件。为此，你不用通过电子邮件将这个大型文件发送  给朋友，而可计算它们的SHA散列值，再对结果进行比较。
- 还可以用SHA检查密码，SHA可以在你不知道原始字符串的情况下对其进行比较，在密码框里输入密码，计算出散列值与密码库进行比对。
- SHA还有一个重要特征，那就是局部不敏感的，即轻微改变字符串，所返回的散列值与改变前差别巨大。
- 可使用Simhash，使散列函数局部敏感，对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别。这让你能够通过比 较散列值来判断两个字符串的相似程度。

19.最安全的密码散列函数——bcrypt。

20.Diffie-Hellman。
- 常用于密码问题，比如Diffie-Hellman 密钥交换，算法主要解决了两个问题，1. 双方无需知道加密算法，他们不必会面协商要使用的加密算法，2. 要破解加密的消息比登天还难。
-  Diffie-Hellman使用两个密钥：公钥和私钥。顾名思义，公钥就是公开的，可将其发布到网站上，通过电子邮件发送给朋友，或使用其他任何方式来发布。你不必将它藏着掖着。有人要向你发送消息时，他使用公钥对其进行加密。加密后的消息只有使用私钥才能解密。只要只有你知道私钥，就只有你才能解密消息！

21.线性规划。
- 线性规划用于在给定约束条件下最大限度地改善指定的指标。
- 所有的图算法都可使用线性规划来实现。
- 线性规划使用Simplex算法。

22.Simplex。

23.排序算法。
- 给定输入序列，排序算法将返回一个序列作为输出，这样的输入序列被称为排序问题的一个实例，一般来说，问题实例由计算该问题解所必需的（满足问题陈述中强加的各种约束的）输入组成。
