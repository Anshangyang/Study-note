# 数据结构/Data Structures

————

序言：此笔记由笔者于《算法图解》、《算法导论》、浙大陈越老师数据结构课进行数据结构的学习中，将作者所提及的概念抽取、汇编而成，第一次完整提交只会摘录对于笔者而言有用部分，后续将在第二次、第三次逐渐完善。

---

# [目录](#目录)
1. [数据结构](#1数据结构)
2. [相关概念或规则](#2相关概念或规则)

---

## 1.数据结构

1.数组。
- 可将一系列元素存储在一系列相邻的桶（bucket），即数组中。
- 需要随机地读取元素时，数组的效率很高，因为可迅 速找到数组的任何元素。

2.链表。
- 链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。
- 需要读取最后一个元素时，不能直接读取，需要同时读取所有元素时，链表效率很高，但如果需要跳跃，链表的效率真的很低。
- 需要在中间插入元素时，链表是更好的选择。如果你要删除元素呢？链表也是更好的选择，因为只需修改前一个元素指向的地址即可。(需要指出的是，仅当能够立即访问要删除的元素时，删除操作的运行时间才为O(1)。通常我们都记录了链表的第一个元素和最后一个元素，因此删除这些元素时运行时间为O(1)。)

3.散列表。
- 散列函数：无论给它一个什么数据，都会返回一个数字，即将输入映射到数字，要求：
    - 输入和映射的数字必须是一致的。
    - 应将不同的输入映射到不同的数字。

    其中，散列函数知道数组多大，只返回有效的索引，使用散列函数和数组就创建了散列表，与数组和链表直接映射到内存不一样，散列表是使用散列函数来确定元素的存储位置。
- 散列表也被称为散列映射、映射、字典和关联数组，速度很快，获取元素的速度与数组一样。
- 使用散列表时，第一步是创建映射，第二步是使用散列表，可用于查找、防止重复、缓存等。
- 冲突，是指在几个键映射到了同一个位置（或类似情形），可在这个位置存储一个链表。
- 性能（或运行时间），散列表执行各种操作的时间都O(1)。O(1)被称为常量时间，不管散列表多大，所需的时间都相同。在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。
- 避免冲突需有较低的填装因子、良好的散列函数。填装因子=散列表包含的元素数/位置总数，而当填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度（resizing），为此，你首先创建一个更长的新数组：通常将数组增长一倍，接下来使用函数将所有的元素都插入到这个新的散列表中。填装因子越低，发生冲突的可能性越小， 散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。
- 散列表是无序的，因此添加键—值对的顺序无关紧要。

4.栈。
- 支持压入（插入）和弹出（删除并读取）的一种遵循后进先出原则的数据类型。 

5.队列（queue）。
- 队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作：入队和出队，是一种先进先出（First In First Out，FIFO）的数据结构。

6.图。
- 图模拟一组连接，由节点（node）和边（edge）组成，一个节点可能与众多节点直接相连，这些节点被称为邻居，关系是单向的是有向图，双向箭头或相连的是无向图。
- 图还可能有环，无向图意味着两个节点彼此指向对方，其实就是环。

7.集合。
- 幂集，可能的子集有2n个，集合不能包含重复的元素，。
- 集合运算，有并集、交集和差集。并集意味着将集合合并。交集意味着找出两个集合中都有的元素。差集意味着将从一个集合中剔除出现在另一个集合中的元素。
- 不可重复。

8.列表。
- 有序性：列表中的元素依照一定的顺序排列，可通过索引访问。
- 可变性：列表的长度和内容可以修改，支持添加、删除和修改操作。
- 可重复性：可存在相同元素。
- 可混合性：可存储不同类型数据。

9.二叉查找树。
- 二叉查找树有一个根节点，根节点下连子节点，子节点在左边就意味着这个子节点的值比根节点小，反之，右子节点比根节点大。且在子节点下还可以连子节点。
-  在二叉查找树中查找节点时，平均运行时间为 O(log n)，但在最糟的情况下所需时间为O(n)。
-  二叉查找树也存在一些缺点，例如，不能随机访问。
-  二叉查找树处于平衡状态时，平均访问时间也为O(log n)，平衡状态是指树的子节点不会堆积在一侧。

10.反向索引。
- 一个散列表，将单词映射到包含它的页面。这种数据结构被称为反向索引（inverted index）常用于创建搜索引擎。

11.布隆过滤器。
- 布隆过滤器是一种概率型数据结构，所求结果有两个要点:
    - 可能出现错报的情况。
    - 不可能出现漏报的情况，其优点在于占用的存储空间很少。


---

## 2.相关概念或规则

1.大O表示法。
是一种特殊的表示法，指出了算法的速度有多快，指的并非以秒为单位的速度，而是用于比较操作数，指出了算法运行时间的增速，随着输入的增加，其运行时间将以什么样的速度增加。

2.索引。
元素的位置称为索引。

3.随机访问。

4.顺序访问。
顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问。

5.递归。
每个递归函数都有两部分：基线条件（base case和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环，也使用调用栈。

6.调用函数。
- 每当你调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。
- 调用另一个函数时，当前函数暂停并处于未完成状态。
- 递归中使用调用栈，这个栈还包含未完成的函数调用时，将对未完成的函数调用保存。

7.分而治之（divide and conquer，D&C）一种著名的递归式问题解决方法。
- 使用D&C解决问题的过程包括两个步骤。一、找出基线条件，这种条件必须尽可能简单。二、不断将问题分解（或者说缩小规模），直到符合基线条件。
- 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时， 请检查基线条件是不是这样的。

8.归纳证明。
归纳证明是一种证明算法行之有效的方式，它分两步：基线条件和归纳条件。归纳条件是我做完这一步后，我可以做出什么？基线条件是我已经做完第一步了。

9.常量。
c是算法所需的固定时间量，通常不考虑这个常量，因为如果两种算法的大O运行时间不同，这种常量将无关紧要。

10.NP完全问题。
以难解著称的问题。如何判断呢？

    - 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
    - 涉及“所有组合”的问题通常是NP完全问题。
    - 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。
    - 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。
    - 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。
    - 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。

NP完全问题具有一个非凡的性质，如果任何一个NP完全问题存在有效算法，那么所有NP完全问题都存在有效算法。

11.近似求解。
一个最接近最优解的解。判断近似算法优劣的标准如下:
- 速度有多快。
- 得到的近似解与最优解的接近程度。

12.最长公共子串问题（最长公共子序列）。
使用动态规划时，答案为网格中最大的数字——它可能并不位于最后的单元格中。

13.编辑距离（levenshtein distance）。
指出了两个字符串的相似程度，也是使用动态规划计算得到的。

---
